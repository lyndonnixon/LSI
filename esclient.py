# -*- coding: UTF-8 -*-
"""ElasticSearch client implemented based on its RESTful API.

.. moduleauthor:: Dong Liu <liu.dong66@gmail.com>
"""
import json
import httplib2
import model


class ElasticSearchError(Exception):
    pass


class ElasticSearchClient(object):

    def __init__(self, endpoint):
        self.endpoint = endpoint

    def _index_data(self, data_type, data):
        endpoint = self.endpoint + '/lsi/' + data_type + '?parent=media'
        response, content = httplib2.Http().request(endpoint, 'POST', body=data)
        if response.status == 201:
            return json.loads(content)['_id']
        else:
            raise ElasticSearchError(content)

    def index_video(self, video_data):
        """Save and index metadata of video.

        Args:
            video_data (str): JSON serialization of the metadata of a video track.

        Returns
            (str): the ID of the video auto-generated by ElasticSearch
        """
        return self._index_data('video', video_data)

    def index_image(self, image_data):
        """Save and index metadata of image.

        Args:
            image_data (str): JSON serialization of the metadata of an image.

        Returns
            (str): the ID of the image auto-generated by ElasticSearch
        """
        return self._index_data('image', image_data)

    def get_video(self, video_id):
        """Retrieve the metadata of a video from ElasticSearch.

        Args:
            video_id (str): ID of the video

        Returns
            (object): instance of model.VideoTrack
        """
        endpoint = self.endpoint + '/lsi/video/' + video_id + '?routing=media'
        response, content = httplib2.Http().request(endpoint, 'GET')
        if response.status == 200:
            source = json.loads(content)['_source']
            return self._create_video(video_id, source)
        else:
            raise ElasticSearchError(content)

    def _create_video(self, video_id, source):
        video = model.VideoTrack()
        video.id = video_id
        video.status = source['status']
        video.description = source['description']
        video.created = source['created']
        video.title = source['title']
        video.source = source['source']
        video.query_lod = source['query_lod']
        video.keywords = source['keywords']
        if 'duration' in source:
            video.duration = source['duration']
        video.locator = source['locator']
        if 'thumbnail' in source:
            video.thumbnail = source['thumbnail']
        video.query_context = source['query_context']
        # desirable metadata
        try:
            video.width = source['width']
            video.height = source['height']
            video.published = source['published']
            video.latitude = source['latitude']
            video.longitude = source['longitude']
            video.location_name = source['location_name']
            video.author_name = source['author_name']
            video.author_uri = source['author_uri']
        except KeyError:
            pass
        return video

    def find_media_by_locator(self, locator):
        """Find media resources by a locator.

        As media resources sharing the same locator can be collected from different sources, this function will return a list rather than a single instance of model.VideoTrack or model.Image.

        Args:
            locator (str): URL of the media resource

        Returns:
            (list): a list of media resources
        """
        query = '{"query": {"match" : {"locator": {"query" : "' + locator + '", "type": "phrase"}}}}'
        endpoint = self.endpoint + '/lsi/_search'
        response, content = httplib2.Http().request(endpoint, 'GET', body=query)
        if response.status == 200:
            media_list = []
            for hit in json.loads(content)['hits']['hits']:
                if hit['_type'] == 'video':
                    video = self._create_video(hit['_id'], hit['_source'])
                    media_list.append(video)
                elif hit['_type'] == 'image':
                    image = self._create_image(hit['_id'], hit['_source'])
                    media_list.append(image)
            return media_list
        else:
            raise ElasticSearchError(content)

    def _create_image(self, image_id, source):
        image = model.Image()
        image.id = image_id
        image.status = source['status']
        image.description = source['description']
        image.created = source['created']
        image.title = source['title']
        image.source = source['source']
        image.query_lod = source['query_lod']
        image.keywords = source['keywords']
        image.locator = source['locator']
        image.query_context = source['query_context']
        # desirable metadata
        try:
            image.width = source['width']
            image.height = source['height']
            image.published = source['published']
            image.latitude = source['latitude']
            image.longitude = source['longitude']
            image.location_name = source['location_name']
            image.author_name = source['author_name']
            image.author_uri = source['author_uri']
        except KeyError:
            pass
        return image

    def count_video(self, lod_uri, context):
        """Count the number of videos crawled for a certain LOD resource and a context.

        Args:
            lod_uri (str): the URI of the LOD resource

            context (str): the URI of the context

        Returns:
            (int): the number of the related videos
        """
        if context is None:
            query = '{"query": {\
                    "bool": {\
                        "must": [{\
                            "match_phrase": {"query_lod": "' + lod_uri + '"}\
                        },\
                        {\
                            "match_phrase": {"type": "video"}\
                        }]\
                    }\
                }\
            }'
        else:
            query = '{"query": {\
                    "bool": {\
                        "must": [{\
                            "match_phrase": {"query_lod": "' + lod_uri + '"}\
                        },\
                        {\
                            "match_phrase": {"type": "video"}\
                        },\
                        {\
                            "match_phrase": {"query_context": "' + context + '"}\
                        }]\
                    }\
                }\
            }'
        endpoint = self.endpoint + '/lsi/_search'
        response, content = httplib2.Http().request(endpoint, 'GET', body=query)
        if response.status == 200:
            return int(json.loads(content)['hits']['total'])

    def count_image(self, lod_uri, context):
        """Count the number of images crawled for a certain LOD resource and a context.

        Args:
            lod_uri (str): the URI of the LOD resource

            context (str): the URI of the context

        Returns:
            (int): the number of the related images
        """
        if context is None:
            query = '{"query": {\
                    "bool": {\
                        "must": [{\
                            "match_phrase": {"query_lod": "' + lod_uri + '"}\
                        },\
                        {\
                            "match_phrase": {"type": "image"}\
                        }]\
                    }\
                }\
            }'
        else:
            query = '{"query": {\
                    "bool": {\
                        "must": [{\
                            "match_phrase": {"query_lod": "' + lod_uri + '"}\
                        },\
                        {\
                            "match_phrase": {"type": "image"}\
                        },\
                        {\
                            "match_phrase": {"query_context": "' + context + '"}\
                        }]\
                    }\
                }\
            }'
        endpoint = self.endpoint + '/lsi/_search'
        response, content = httplib2.Http().request(endpoint, 'GET', body=query)
        if response.status == 200:
            return int(json.loads(content)['hits']['total'])

    def get_image(self, image_id):
        """Retrieve the metadata of an image from ElasticSearch.

        Args:
            image_id (str): ID of the image

        Returns
            (object): instance of model.Image
        """
        endpoint = self.endpoint + '/lsi/image/' + image_id + '?routing=media'
        response, content = httplib2.Http().request(endpoint, 'GET')
        if response.status == 200:
            source = json.loads(content)['_source']
            return self._create_image(image_id, source)
        else:
            raise ElasticSearchError(content)

    def _update_data(self, data_type, data_id, data):
        endpoint = self.endpoint + '/lsi/' + data_type + '/' + data_id + '?parent=media'
        response, content = httplib2.Http().request(endpoint, 'PUT', body=data)
        if response.status == 200:
            pass
        else:
            raise ElasticSearchError(content)

    def update_video(self, video_id, data):
        """Update the metadata of a video from ElasticSearch.

        Args:
            video_id (str): ID of the video

            data (string): JSON serialization of the metadata of the video
        """
        return self._update_data('video', video_id, data)

    def update_image(self, image_id, data):
        """Update the metadata of an image from ElasticSearch.

        Args:
            image_id (str): ID of the image

            data (string): JSON serialization of the metadata of the image
        """
        return self._update_data('image', image_id, data)

    def find_media_by_status(self, status):
        """Find media resources by a status, e.g. crawled and enriched.

        Args:
            status (str): the status of media resources

        Returns:
            (list): a list of media resources
        """
        query = '{"query": {"term" : { "status" : "' + status + '" }}}'
        endpoint = self.endpoint + '/lsi/_search'
        response, content = httplib2.Http().request(endpoint, 'GET', body=query)
        if response.status == 200:
            media_list = []
            for hit in json.loads(content)['hits']['hits']:
                if hit['_type'] == 'video':
                    video = self._create_video(hit['_id'], hit['_source'])
                    media_list.append(video)
                elif hit['_type'] == 'image':
                    image = self._create_image(hit['_id'], hit['_source'])
                    media_list.append(image)
            return media_list
        else:
            raise ElasticSearchError(content)

    def is_crawled(self, lod_uri, context_uri):
        """Check if a certain LOD resource and a context have been used in previous crawling.

        Args:
            lod_uri (str): the URI of the LOD resource

            context (str): the URI of the context

        Returns:
            (bool): crawled or not
        """
        if not context_uri:
            query_template = """{"query":{"match_phrase": {"query_lod": "%s"}}}"""
            query = query_template % (lod_uri,)
        else:
            query_template = """{"query":{"bool":{"must": {"match_phrase": {"query_lod": "%s"}},
                                                  "must": {"match_phrase": {"query_context": "%s"}}}}}"""
            query = query_template % (lod_uri, context_uri)
        endpoint = self.endpoint + '/lsi/_search'
        response, content = httplib2.Http().request(endpoint, 'GET', body=query)
        if response.status == 200:
            if json.loads(content)['hits']['total']:
                return True
            else:
                return False
        else:
            raise ElasticSearchError(content)

    def query_by_keywords(self, lod_uri, context_uri, limit=None, media_type='all'):
        """Query for media resources by keywords, i.e. the metadata enrichment results.

        Args:
            lod_uri (str): the URI of the LOD resource

            context (str): the URI of the context

            limit (integer): the number of media resources

            media_type (str): it can be 'all', 'video' or 'image'
        Returns:
            (list): list of related media resources
        """
        if not context_uri:
            query_template = """{"query":{"match_phrase": {"keywords": "%s"}}}"""
            query = query_template % (lod_uri,)
        else:
            query_template = """{"query":{"bool":{"must": {"match_phrase": {"query_lod": "%s"}},
                                                  "must": {"match_phrase": {"keywords": "%s"}}}}}"""
            query = query_template % (lod_uri, context_uri)
        media_type = media_type.lower()
        if media_type == 'video' or media_type == 'image':
            endpoint = self.endpoint + '/lsi/' + media_type + '/_search'
        else:
            endpoint = self.endpoint + '/lsi/_search'
        response, content = httplib2.Http().request(endpoint, 'GET', body=query)
#         print query
        if response.status == 200:
            media_list = []
            for hit in json.loads(content)['hits']['hits']:
                if hit['_type'] == 'video':
                    video = self._create_video(hit['_id'], hit['_source'])
                    media_list.append(video)
                elif hit['_type'] == 'image':
                    image = self._create_image(hit['_id'], hit['_source'])
                    media_list.append(image)
            if limit:
                video_list = [video for video in media_list if isinstance(video, model.VideoTrack)]
                image_list = [image for image in media_list if isinstance(image, model.Image)]
                video_num = (int(limit) / 2) if (int(limit) / 2) < len(video_list) else len(video_list)
                image_num = limit - video_num
                media_list = video_list[0:video_num] + image_list[0:image_num]
            return media_list
        else:
            raise ElasticSearchError(content)
